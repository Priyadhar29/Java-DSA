ðŸ§  Objective:
You are given an integer n.
You can flip exactly one 0 bit to 1 in its binary representation.
Find the maximum value you can get after flipping one and only one bit.

ðŸ“¥ Input Format:
A single integer n

ðŸ“¤ Output Format:
Print the maximum possible integer after flipping one 0 to 1

ðŸ”¢ Sample Input & Output:
Sample Input 1:
29
Binary of 29: 11101

Flipping the only 0 â†’ 11111 â†’ Decimal = 31

âœ… Sample Output:
31
Sample Input 2:
15
Binary of 15: 1111

All bits are already 1, no 0 to flip

So output is same: 15

ðŸ’¡ Approach:
Step-by-step:
Loop through each bit position (from 0 to 31).

For each bit that is 0:

Flip it to 1 using bitwise OR.

Calculate new value and track the maximum.

If all bits are already 1, the result is n.

ðŸ’» Java Code:
import java.util.Scanner;

public class MaxValueAfterOneBitFlip {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int maxVal = n;

        for (int i = 0; i < 32; i++) {
            // Check if i-th bit is 0
            if ((n & (1 << i)) == 0) {
                int flipped = n | (1 << i); // Flip 0 to 1 at i-th position
                maxVal = Math.max(maxVal, flipped);
            }
        }

        System.out.println(maxVal);
    }
}

ðŸ” for (int i = 0; i < 32; i++)
Loops over all 32 bit positions (Java int is 32-bit).

i = 0 is the least significant bit (LSB) (rightmost), up to i = 31 (most significant bit/MSB).

âš™ï¸ if ((n & (1 << i)) == 0)
This checks if the i-th bit in n is 0.

Here's how it works:
(1 << i)

Shifts 1 to the i-th bit position.

For example:

i = 0 â†’ 1 (binary 000...0001)

i = 3 â†’ 8 (binary 000...1000)

n & (1 << i)

This performs a bitwise AND between n and the mask.

If the i-th bit in n is 0, result will be 0 â†’ == 0 is true.

ðŸ” Example:
Letâ€™s say n = 29 (binary 0001 1101)

We're looping over all bit positions:

At i = 1:
(1 << 1) â†’ binary 0000 0010 (value = 2)

n & (1 << 1) â†’ 0001 1101 & 0000 0010 = 0000 0000

So, bit 1 in n is 0 âœ…

âœ… int flipped = n | (1 << i);
If bit i is 0, we flip it to 1 using bitwise OR.

n | (1 << i) sets the i-th bit to 1.

Example:
n = 29 (binary 0001 1101)

At i = 1, flipping gives:

(1 << 1) = 2 â†’ binary 0000 0010

29 | 2 = 31 â†’ binary 0001 1111

ðŸ”¼ maxVal = Math.max(maxVal, flipped);
Keep track of the maximum value generated by flipping each 0 to 1.

âœ… Summary:
| Step                            | Action                   |                    |
| ------------------------------- | ------------------------ | ------------------ |
| Loop `i = 0` to `31`            | Check every bit position |                    |
| If bit `i` is `0`               | Flip it to `1`           |                    |
| Calculate \`flipped = n         | (1 << i)\`               | Get the new number |
| Update `maxVal` if it's greater | Track the maximum result |                    |
